<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>destructOgraphic</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: black;
      overflow: hidden;
      height: 100%;
      width: 100%;
    }
    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
    }
  </style>
</head>
<body>
  <canvas id="glcanvas"></canvas>
  <script>
    const canvas = document.getElementById("glcanvas");
    const gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");

    function resize() {
      const dpr = window.devicePixelRatio || 1;
      canvas.width = window.innerWidth * dpr;
      canvas.height = window.innerHeight * dpr;
      canvas.style.width = window.innerWidth + "px";
      canvas.style.height = window.innerHeight + "px";
      gl.viewport(0, 0, canvas.width, canvas.height);
    }
    window.addEventListener("resize", resize);
    resize();

    const vsSource = `
      attribute vec3 position;
      uniform mat4 modelViewMatrix;
      uniform mat4 projectionMatrix;
      void main(void) {
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `;

    const fsSource = `
      precision mediump float;
      void main(void) {
        float flicker = step(0.9, fract(sin(gl_FragCoord.y * 4.0 + gl_FragCoord.x * 0.5) * 43758.5453));
        float noise = fract(sin(gl_FragCoord.x * 12.9898 + gl_FragCoord.y * 78.233) * 43758.5453);
        vec3 color = mix(vec3(1.0), vec3(1.0, 0.2, 0.2), flicker * noise);
        gl_FragColor = vec4(color, 1.0);
      }
    `;

    function compileShader(src, type) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, src);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error("Shader compile error:", gl.getShaderInfoLog(shader));
        return null;
      }
      return shader;
    }

    const vs = compileShader(vsSource, gl.VERTEX_SHADER);
    const fs = compileShader(fsSource, gl.FRAGMENT_SHADER);
    const program = gl.createProgram();
    gl.attachShader(program, vs);
    gl.attachShader(program, fs);
    gl.linkProgram(program);
    gl.useProgram(program);

    const positionLoc = gl.getAttribLocation(program, "position");
    const modelViewLoc = gl.getUniformLocation(program, "modelViewMatrix");
    const projectionLoc = gl.getUniformLocation(program, "projectionMatrix");

    const pyramidVertices = new Float32Array([
      -1, 0, -1,
       1, 0, -1,
       1, 0,  1,
      -1, 0,  1,
       0, 1.5, 0
    ]);

    const pyramidEdges = new Uint16Array([
      0, 1, 1, 2, 2, 3, 3, 0,
      0, 4, 1, 4, 2, 4, 3, 4
    ]);

    const vbo = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
    gl.bufferData(gl.ARRAY_BUFFER, pyramidVertices, gl.STATIC_DRAW);

    const ebo = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ebo);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, pyramidEdges, gl.STATIC_DRAW);

    gl.enableVertexAttribArray(positionLoc);
    gl.vertexAttribPointer(positionLoc, 3, gl.FLOAT, false, 0, 0);

    function mat4Perspective(fov, aspect, near, far) {
      const f = 1.0 / Math.tan(fov / 2);
      const nf = 1 / (near - far);
      return [
        f / aspect, 0, 0, 0,
        0, f, 0, 0,
        0, 0, (far + near) * nf, -1,
        0, 0, (2 * far * near) * nf, 0
      ];
    }

    function render(time) {
      time *= 0.001;

      gl.clearColor(0.0, 0.0, 0.0, 1.0);
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

      const aspect = canvas.width / canvas.height;
      const proj = mat4Perspective(Math.PI / 3, aspect, 0.1, 100);

      const yaw = time * 0.6;
      const pitch = Math.sin(time * 0.7) * 0.5;
      const roll = Math.cos(time * 0.9) * 0.3;

      const cy = Math.cos(yaw), sy = Math.sin(yaw);
      const cp = Math.cos(pitch), sp = Math.sin(pitch);
      const cr = Math.cos(roll), sr = Math.sin(roll);

      const mv = [
        cr * cy + sr * sp * sy, sr * cp, cr * -sy + sr * sp * cy, 0,
        -sr * cy + cr * sp * sy, cr * cp, sr * sy + cr * sp * cy, 0,
        cp * sy, -sp, cp * cy, 0,
        0, 0, -5, 1
      ];

      gl.uniformMatrix4fv(modelViewLoc, false, new Float32Array(mv));
      gl.uniformMatrix4fv(projectionLoc, false, new Float32Array(proj));

      gl.drawElements(gl.LINES, pyramidEdges.length, gl.UNSIGNED_SHORT, 0);

      requestAnimationFrame(render);
    }

    requestAnimationFrame(render);
  </script>
</body>
</html>
